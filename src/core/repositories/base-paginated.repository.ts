import { BadRequestException } from '@nestjs/common';
import { DeepPartial, Repository, SelectQueryBuilder } from 'typeorm';
import { PaginationModel } from '../models/pagination.model';

export abstract class BasePaginatedRepository<T> extends Repository<T> {
  /**
   * Functions that adds pagination to a query
   * @param query - Typeorm select query to apply pagination
   * @param page  - Page number to get results
   * @param limit - Limit number of results
   * @param queryResults - Used to know if should return values or not (default true)
   * @returns Promise with pagination model and data of the entity repository that uses it
   */
  async getEntityPagination(
    query: SelectQueryBuilder<T>,
    page: number,
    limit: number,
    queryResults = true,
    manualPagination = false,
  ): Promise<{ pagination: PaginationModel; data: T[] }> {
    let data: T[] = [];
    const { pagination, skippedItems } = await this.getPaginationMetadata(
      query,
      page,
      limit,
      queryResults,
    );
    // Apply pagination to query received
    if (!pagination.totalItems) return { pagination, data };

    if (!manualPagination) {
      data = await query.skip(skippedItems).take(limit).getMany();
    } else {
      // This pagination is manually generated by splitting and array, given the page and limit values
      // TypeORM doesn't return the right quantity of items per page when combining sort of many to many entities with pagination methods
      data = await query.getMany();
      data = data.slice(skippedItems).slice(0, limit);
    }
    return { pagination, data };
  }

  /**
   * Functions that generates the pagination metadata
   * @param query - Typeorm select query to count the total items
   * @param page  - Page number to get results
   * @param limit - Limit number of results
   * @param queryResults - Used to know if should return values or not (default true)
   * @returns Promise with pagination model and skippedItems to use on pagination query
   */
  async getPaginationMetadata(
    query: SelectQueryBuilder<T>,
    page: number,
    limit: number,
    queryResults = true,
  ): Promise<{ pagination: PaginationModel; skippedItems: number }> {
    const pagination = new PaginationModel();
    const skippedItems = (page - 1) * limit; // Index of elements to skip in the query
    const lastItem = page * limit;

    pagination.page = page;
    pagination.limit = limit;
    pagination.totalItems = queryResults ? await query.getCount() : 0;
    pagination.totalPages = Math.ceil(pagination.totalItems / limit); // Assigns the nearest upward integer

    // If previous filters on the query doesn't provide results, return the initialized values
    if (!queryResults) return { pagination, skippedItems };

    // Only add next page element if last item is lower than all the elements
    if (lastItem < pagination.totalItems) {
      pagination.nextPage = page + 1;
    }
    // Only add previous page element if skipped item index is more than zero
    if (skippedItems > 0) {
      pagination.previousPage = page - 1;
    }

    return { pagination, skippedItems };
  }

  /**
   * Check if the entity exists by the given deep entity props, otherwise a new one will be created
   *
   * @param deepEntityProps - Entity column deepEntityProps
   * @param partialEntityProps - Entity partial props required in order to be able to create it
   * @param relations - Optional entity relations
   * @returns An instance of {@link T}
   */
  async findByPropsOrCreate(
    deepEntityProps: DeepPartial<T>,
    partialEntityProps?: DeepPartial<T>,
    relations?: string[],
  ): Promise<Awaited<T>> {
    const entity = this.create(deepEntityProps);
    const foundEntity = await this.findOne(entity, { relations });

    return foundEntity ?? ((await this.save({ ...entity, ...partialEntityProps })) as Awaited<T>);
  }

  async updatePartial(where: Partial<T>, patch: DeepPartial<T>): Promise<Awaited<T>> {
    const entity = await this.findOne({ where });

    if (entity) throw new BadRequestException('This value already exists');

    return (await this.save({ ...entity, ...patch })) as Awaited<T>;
  }
}
